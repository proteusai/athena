import { Node, Project } from 'ts-morph';
import { IAction, IRunContext } from '../../action';
import { SafeFS } from '../../fs';
import Logger from '../../utils/logger';
import emitSchema from './emitters/emit-schema';
import emitModel from './emitters/emit-model';
import emitEnum from './emitters/emit-enum';
import emitType from './emitters/emit-type';

export default class PrismaAction implements IAction {
    public async run(context: IRunContext) {
        if (context.shouldOutputPrima === false) {
            return;
        }
        if (!context.isServer && typeof context.shouldOutputPrima === 'undefined') {
            return;
        }

        this.createRootDirectory(context.fs);
        this.createSchemaFile(context.fs);

        this.emitSchemaFileContent(context.fs);
        await this.emitCodeGensFileContent(context.fs, context.project);
    }

    private async createRootDirectory(fs: SafeFS) {
        fs.createDirectorySync('prisma');
    }

    private async createSchemaFile(fs: SafeFS) {
        if (fs.existsSync('prisma/schema.prisma')) {
            return;
        }
        fs.createFile('prisma/schema.prisma');
    }

    private emitSchemaFileContent(fs: SafeFS) {
        const writeStream = fs.createWriteStream('prisma/schema.prisma');
        emitSchema(writeStream);
        Logger.logGeneratedFile('prisma/schema.prisma');
    }

    private async emitCodeGensFileContent(fs: SafeFS, project: Project) {
        project.getSourceFiles().forEach((sourceFile) => {
            const isThereAnyDecorator = sourceFile.getClasses().some((cls) => {
                const decorators = cls.getDecorators();
                return decorators.some((dec) => dec.getName() === 'model');
            });

            if (!isThereAnyDecorator) {
                return;
            }

            const fileName = `prisma/${sourceFile.getBaseNameWithoutExtension().toLowerCase()}.codegen.prisma`;
            fs.createFile(fileName);
            const writeStream = fs.createWriteStream(fileName);
            writeStream.write('// This file is always auto-generated; do NOT edit this file\n\n');

            sourceFile.forEachChild((child) => {
                if (Node.isClassDeclaration(child)) {
                    const decorators = child.getDecorators();
                    const decorator = decorators.find((dec) => dec.getName() === 'model' || dec.getName() === 'type' || dec.getName() === 'Enum');

                    if (decorator) {
                        const type = child.getDecorators().find((dec) => dec.getName() === 'model')
                            ? 'model'
                            : child.getDecorators().find((dec) => dec.getName() === 'type')
                            ? 'type'
                            : 'enum';
                        emitModel(writeStream, child);
                        Logger.logCreatedObject(`${child.getName()} ${type}`);
                    }
                }

                if (Node.isInterfaceDeclaration(child)) {
                    emitType(writeStream, child);
                    Logger.logCreatedObject(`${child.getName()} type`);
                }

                if (Node.isEnumDeclaration(child)) {
                    emitEnum(writeStream, child);
                    Logger.logCreatedObject(`${child.getName()} enum`);
                }
            });

            Logger.logGeneratedFile(fileName);
        });
    }
}
